# of the inequalities
lower = c(sum(ATF$var_CPUE)*var_constraint, number_of_stations)
upper = c(sum(variances), number_of_stations)
# Specify the type of structural variable. Integers refer to different types.
# See ?glpkAPI::glpkConstants() for the set of variable types.
# "2" refers to a variable with a lower bound and
# "3" refers a variable with an upper bound
# "5" refers to a fixed variable
bound_type = c(2, #total variance has a lower bound
5) #Fixed variable
glpkAPI::setRowsBndsGLPK(lp = model,
i = seq_along(upper),
lb = lower, ub = upper,
type = bound_type )
# Presolve and automatically calculate relaxed solution
# otherwise glpkAPI::solveSimplexGLPK(model) must be called first
glpkAPI::setMIPParmGLPK(parm = PRESOLVE, val = GLP_ON)
glpkAPI::setMIPParmGLPK(parm = MSG_LEV, val = GLP_MSG_ALL)
# Set the maximum optimality gap of the solution
glpkAPI::setMIPParmGLPK(parm = MIP_GAP, val = 0.001)
# Stop after specified number of seconds, convert to milliseconds
glpkAPI::setMIPParmGLPK(parm = TM_LIM, val = 1000 * 60)
#############################
## Solve Model
#############################
screen_out = glpkAPI::solveMIPGLPK(lp = model)
#############################
## Prepare return object
#############################
results <- list(output_code = screen_out,
status = glpkAPI::return_codeGLPK(screen_out),
objval = glpkAPI::mipObjValGLPK(model),
x = glpkAPI::mipColsValGLPK(model) )
results$tot_var = sum(variances[results$x == 1])
results$rel_var = results$tot_var / sum(variances)
#Delete model
glpkAPI::delProbGLPK(lp = model)
return(results)
}
x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.93)
x
head(ATF)
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1])
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
x
x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.94)
x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 300,
var_constraint = 0.1)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 300,
var_constraint = 0.1))
sum(tot_var)
sum(ATF$var_CPUE)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 200,
var_constraint = 0.1))
sum(ATF$mean_CPUE)
sum(ATF$var_CPUE == 0)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 200,
var_constraint = 0.1))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.93))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.935))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.94))
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.1))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
plot(lat ~ long, data = ATF, cex = var_CPUE/1e6)
plot(lat ~ long, data = ATF, cex = var_CPUE/1e5)
plot(lat ~ long, data = ATF, cex = var_CPUE/1e4)
plot(lat ~ long, data = ATF, cex = var_CPUE/1e5)
plot(lat ~ long, data = ATF, cex = var_CPUE/2e5)
plot(lat ~ long, data = ATF, cex = var_CPUE/2e5. pch = 16)
plot(lat ~ long, data = ATF, cex = var_CPUE/2e5, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/2e5, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/2e3, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/5e3, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/1e3, pch = 16)
ATF = read.csv('10130_stations_.csv')
plot(lat ~ long, data = ATF, cex = var_CPUE/2e5, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/1e3, pch = 16)
library(glpkAPI)
do_optim = function(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1){
##############################
## Defining the Model
###############################
# Initialize Model
model <- glpkAPI::initProbGLPK()
# Set objective function as a minimization funtion
glpkAPI::setObjDirGLPK(lp = model,
lpdir = glpkAPI::GLP_MAX)
# Initialize decision variables (columns)
glpkAPI::addColsGLPK(lp = model,
ncols = nrow(ATF))
# Set the objective function, specify no bounds on decision variables
# GLP_FR means free variable
glpkAPI::setColsBndsObjCoefsGLPK(lp = model,
j = seq_along(objvals),
lb = NULL, ub = NULL,
obj_coef = objvals,
type = rep(glpkAPI::GLP_FR, length(objvals)))
# Specify that decision variables are binary. GLP_BV means binary variable
glpkAPI::setColsKindGLPK(lp = model,
j = seq_along(objvals),
kind = rep(glpkAPI::GLP_BV, length(objvals)))
# Initialize the structural constraints (rows)
# There is 1 constraint for the total variance, another for the number of stations
glpkAPI::addRowsGLPK(lp = model,
nrows = 2)
mr = rep(1:2, each = length(objvals))
mc = rep(1:length(objvals), times = 2)
mz = c(variances, rep(1, length(objvals)))
# set non-zero elements of constraint matrix
glpkAPI::loadMatrixGLPK(lp = model,
ne = length(mz),
ia = mr, ja = mc, ra = mz)
# Set the lower and upper bounds for the right-hand side
# of the inequalities
lower = c(sum(ATF$var_CPUE)*var_constraint, number_of_stations)
upper = c(sum(variances), number_of_stations)
# Specify the type of structural variable. Integers refer to different types.
# See ?glpkAPI::glpkConstants() for the set of variable types.
# "2" refers to a variable with a lower bound and
# "3" refers a variable with an upper bound
# "5" refers to a fixed variable
bound_type = c(2, #total variance has a lower bound
5) #Fixed variable
glpkAPI::setRowsBndsGLPK(lp = model,
i = seq_along(upper),
lb = lower, ub = upper,
type = bound_type )
# Presolve and automatically calculate relaxed solution
# otherwise glpkAPI::solveSimplexGLPK(model) must be called first
glpkAPI::setMIPParmGLPK(parm = PRESOLVE, val = GLP_ON)
glpkAPI::setMIPParmGLPK(parm = MSG_LEV, val = GLP_MSG_ALL)
# Set the maximum optimality gap of the solution
glpkAPI::setMIPParmGLPK(parm = MIP_GAP, val = 0.001)
# Stop after specified number of seconds, convert to milliseconds
glpkAPI::setMIPParmGLPK(parm = TM_LIM, val = 1000 * 60)
#############################
## Solve Model
#############################
screen_out = glpkAPI::solveMIPGLPK(lp = model)
#############################
## Prepare return object
#############################
results <- list(output_code = screen_out,
status = glpkAPI::return_codeGLPK(screen_out),
objval = glpkAPI::mipObjValGLPK(model),
x = glpkAPI::mipColsValGLPK(model) )
results$tot_var = sum(variances[results$x == 1])
results$rel_var = results$tot_var / sum(variances)
#Delete model
glpkAPI::delProbGLPK(lp = model)
return(results)
}
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.1))
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
setwd('C:/Users/zack.oyafuso/Work/GitHub/MS_OM_GoA/Optimization_BeringSea')
ATF = read.csv('10130_stations_.csv')
plot(lat ~ long, data = ATF, cex = var_CPUE/2e5, pch = 16)
plot(lat ~ long, data = ATF, cex = var_CPUE/2e6, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/1e3, pch = 16)
library(glpkAPI)
do_optim = function(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1){
##############################
## Defining the Model
###############################
# Initialize Model
model <- glpkAPI::initProbGLPK()
# Set objective function as a minimization funtion
glpkAPI::setObjDirGLPK(lp = model,
lpdir = glpkAPI::GLP_MAX)
# Initialize decision variables (columns)
glpkAPI::addColsGLPK(lp = model,
ncols = nrow(ATF))
# Set the objective function, specify no bounds on decision variables
# GLP_FR means free variable
glpkAPI::setColsBndsObjCoefsGLPK(lp = model,
j = seq_along(objvals),
lb = NULL, ub = NULL,
obj_coef = objvals,
type = rep(glpkAPI::GLP_FR, length(objvals)))
# Specify that decision variables are binary. GLP_BV means binary variable
glpkAPI::setColsKindGLPK(lp = model,
j = seq_along(objvals),
kind = rep(glpkAPI::GLP_BV, length(objvals)))
# Initialize the structural constraints (rows)
# There is 1 constraint for the total variance, another for the number of stations
glpkAPI::addRowsGLPK(lp = model,
nrows = 2)
mr = rep(1:2, each = length(objvals))
mc = rep(1:length(objvals), times = 2)
mz = c(variances, rep(1, length(objvals)))
# set non-zero elements of constraint matrix
glpkAPI::loadMatrixGLPK(lp = model,
ne = length(mz),
ia = mr, ja = mc, ra = mz)
# Set the lower and upper bounds for the right-hand side
# of the inequalities
lower = c(sum(ATF$var_CPUE)*var_constraint, number_of_stations)
upper = c(sum(variances), number_of_stations)
# Specify the type of structural variable. Integers refer to different types.
# See ?glpkAPI::glpkConstants() for the set of variable types.
# "2" refers to a variable with a lower bound and
# "3" refers a variable with an upper bound
# "5" refers to a fixed variable
bound_type = c(2, #total variance has a lower bound
5) #Fixed variable
glpkAPI::setRowsBndsGLPK(lp = model,
i = seq_along(upper),
lb = lower, ub = upper,
type = bound_type )
# Presolve and automatically calculate relaxed solution
# otherwise glpkAPI::solveSimplexGLPK(model) must be called first
glpkAPI::setMIPParmGLPK(parm = PRESOLVE, val = GLP_ON)
glpkAPI::setMIPParmGLPK(parm = MSG_LEV, val = GLP_MSG_ALL)
# Set the maximum optimality gap of the solution
glpkAPI::setMIPParmGLPK(parm = MIP_GAP, val = 0.001)
# Stop after specified number of seconds, convert to milliseconds
glpkAPI::setMIPParmGLPK(parm = TM_LIM, val = 1000 * 60)
#############################
## Solve Model
#############################
screen_out = glpkAPI::solveMIPGLPK(lp = model)
#############################
## Prepare return object
#############################
results <- list(output_code = screen_out,
status = glpkAPI::return_codeGLPK(screen_out),
objval = glpkAPI::mipObjValGLPK(model),
x = glpkAPI::mipColsValGLPK(model) )
results$tot_var = sum(variances[results$x == 1])
results$rel_var = results$tot_var / sum(variances)
#Delete model
glpkAPI::delProbGLPK(lp = model)
return(results)
}
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.96))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
{(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.965))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)}
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.97))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.975))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.98))
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.98))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
ATF = read.csv('10210_stations_.csv')
plot(lat ~ long, data = ATF, cex = var_CPUE/2e6, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/1e3, pch = 16)
ATF = read.csv('10210_stations_.csv')
plot(lat ~ long, data = ATF, cex = var_CPUE/2e6, pch = 16)
plot(lat ~ long, data = ATF, cex = mean_CPUE/1e3, pch = 16)
library(glpkAPI)
do_optim = function(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 100,
var_constraint = 0.1){
##############################
## Defining the Model
###############################
# Initialize Model
model <- glpkAPI::initProbGLPK()
# Set objective function as a minimization funtion
glpkAPI::setObjDirGLPK(lp = model,
lpdir = glpkAPI::GLP_MAX)
# Initialize decision variables (columns)
glpkAPI::addColsGLPK(lp = model,
ncols = nrow(ATF))
# Set the objective function, specify no bounds on decision variables
# GLP_FR means free variable
glpkAPI::setColsBndsObjCoefsGLPK(lp = model,
j = seq_along(objvals),
lb = NULL, ub = NULL,
obj_coef = objvals,
type = rep(glpkAPI::GLP_FR, length(objvals)))
# Specify that decision variables are binary. GLP_BV means binary variable
glpkAPI::setColsKindGLPK(lp = model,
j = seq_along(objvals),
kind = rep(glpkAPI::GLP_BV, length(objvals)))
# Initialize the structural constraints (rows)
# There is 1 constraint for the total variance, another for the number of stations
glpkAPI::addRowsGLPK(lp = model,
nrows = 2)
mr = rep(1:2, each = length(objvals))
mc = rep(1:length(objvals), times = 2)
mz = c(variances, rep(1, length(objvals)))
# set non-zero elements of constraint matrix
glpkAPI::loadMatrixGLPK(lp = model,
ne = length(mz),
ia = mr, ja = mc, ra = mz)
# Set the lower and upper bounds for the right-hand side
# of the inequalities
lower = c(sum(ATF$var_CPUE)*var_constraint, number_of_stations)
upper = c(sum(variances), number_of_stations)
# Specify the type of structural variable. Integers refer to different types.
# See ?glpkAPI::glpkConstants() for the set of variable types.
# "2" refers to a variable with a lower bound and
# "3" refers a variable with an upper bound
# "5" refers to a fixed variable
bound_type = c(2, #total variance has a lower bound
5) #Fixed variable
glpkAPI::setRowsBndsGLPK(lp = model,
i = seq_along(upper),
lb = lower, ub = upper,
type = bound_type )
# Presolve and automatically calculate relaxed solution
# otherwise glpkAPI::solveSimplexGLPK(model) must be called first
glpkAPI::setMIPParmGLPK(parm = PRESOLVE, val = GLP_ON)
glpkAPI::setMIPParmGLPK(parm = MSG_LEV, val = GLP_MSG_ALL)
# Set the maximum optimality gap of the solution
glpkAPI::setMIPParmGLPK(parm = MIP_GAP, val = 0.001)
# Stop after specified number of seconds, convert to milliseconds
glpkAPI::setMIPParmGLPK(parm = TM_LIM, val = 1000 * 60)
#############################
## Solve Model
#############################
screen_out = glpkAPI::solveMIPGLPK(lp = model)
#############################
## Prepare return object
#############################
results <- list(output_code = screen_out,
status = glpkAPI::return_codeGLPK(screen_out),
objval = glpkAPI::mipObjValGLPK(model),
x = glpkAPI::mipColsValGLPK(model) )
results$tot_var = sum(variances[results$x == 1])
results$rel_var = results$tot_var / sum(variances)
#Delete model
glpkAPI::delProbGLPK(lp = model)
return(results)
}
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.9))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.985))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.99))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
source('~/.active-rstudio-document', echo=TRUE)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 150,
var_constraint = 0.98))
sum(x$x)
(x = do_optim(objvals = ATF$mean_CPUE,
variances = ATF$var_CPUE,
number_of_stations = 200,
var_constraint = 0.98))
plot(lat ~ long, data = ATF)
points(lat ~ long, data = ATF[x$x == 1,], pch = 16)
source('~/.active-rstudio-document', echo=TRUE)
df = data.frame
for(spp in c(10110, 10130, 10210)){
df = rbind(df, read.csv(paste0(spp, '_stations_.csv')))
}
read.csv(paste0(spp, '_stations_.csv'))
df = data.frame()
for(spp in c(10110, 10130, 10210)){
df = rbind(df, read.csv(paste0(spp, '_stations_.csv')) )
}
df
unique(df$STATIONID)
id = unique(df$STATIONID)[1]
temp_df = subset(df, STATIONID == id)
head(temp_df)
temp_df = read.csv(paste0(spp, '_stations_.csv'))
df = data.frame()
for(spp in c(10110, 10130, 10210)){
temp_df = read.csv(paste0(spp, '_stations_.csv'))
df = rbind(df,  data.frame(cbind(spp = spp, temp_df)))
}
head(df)
temp_df = subset(df, STATIONID == id)
head(temp-df)
temp_df
df = data.frame()
for(spp in c(10110, 10130, 10210)){
temp_df = read.csv(paste0(spp, 'final.csv'))
df = rbind(df,  data.frame(cbind(spp = spp, temp_df)))
}
rm(temp_df, spp)
id = unique(df$STATIONID)[1]
id
head(temp_df)
head(df)
rm(list=ls())  #clears history
gc()
rm(list=ls())  #clears history
gc()
####### Setting lists of required packages & installing it
list_rpackage <- c("raster", "rgdal", "maptools", "gstat", "rgeos", "proj4", "PBSmapping", "sp", "ncdf4", "INLA", "gridExtra",
"splancs", "automap", "gtools", "reshape", "fields", "dplyr", "ggplot2", "reshape2", "tidyverse")
which_not_installed <- which(list_rpackage %in% rownames(installed.packages()) == FALSE)
which_not_installed
if(length(which_not_installed)>1)
{
install.packages(list_rpackage[which_not_installed],dep=TRUE)
if ("INLA" %in% list_rpackage[which_not_installed]) install.packages("INLA", repos=c(getOption("repos"),
INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
}
# loading the packages
lapply(list_rpackage, require, character.only = TRUE)
####### Setting lists of required packages & installing it
list_rpackage <- c("raster", "rgdal", "maptools", "gstat", "rgeos", "proj4", "PBSmapping", "sp", "ncdf4", "INLA", "gridExtra",
"splancs", "automap", "gtools", "reshape", "fields", "dplyr", "ggplot2", "reshape2", "tidyverse")
which_not_installed <- which(list_rpackage %in% rownames(installed.packages()) == FALSE)
if(length(which_not_installed)>1)
{
install.packages(list_rpackage[which_not_installed],dep=TRUE)
if ("INLA" %in% list_rpackage[which_not_installed]) install.packages("INLA", repos=c(getOption("repos"),
INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
}
# loading the packages
lapply(list_rpackage, require, character.only = TRUE)
#run this once
original_dataset <- sumHaul(getRacebase(year=c(1982, 2019), survey = 'EBS_SHELF'))
?sumHaul
