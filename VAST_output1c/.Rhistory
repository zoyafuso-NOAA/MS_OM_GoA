)
i = 2
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
nrow(ind_ar)
for(i in 1:nrow(ind_ar)){
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
for(i in 1:nrow(ind_ar)){
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
par(oma= c(2,2,2,2))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
par(oma= c(5,5,5,5))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(5,5,5,5)
)
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(1,1,1,1))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(0,0,0,0))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(10,10,10,10))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(20,20,20,20))
}
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(15,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(12,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(11,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(10,4))
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(10,4))
}
ind_ar
load("C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/VAST_output3/VAST_MS_GoA_Run.RData")
Save$Spp
Save$Opt$Convergence_check
###############################
## Spatial Settings for VAST
###############################
rm(list = ls())
library(VAST)
install.packages("devtools")
library("devtools")
install.packages('processx')
library("devtools")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
install.packages('digest')
install.packages("digest")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
library("devtools")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
library(devtools)
install.packages('fs')
library(devtools)
install.packages("TMB")
install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
library(devtools)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install.packages('glue')
install.packages("glue")
library(devtools)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install.packages('ps')
install.packages("ps")
library(devtools)
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install.packages("devtools") # if you have not installed "devtools" package
devtools::install_github("hoxo-m/githubinstall")
devtools::install_github("hoxo-m/githubinstall")
install.packages("githubinstall")
library(githubinstall)
githubinstall("FishStatsUtils")
install.packages(c("BH", "broom", "Cairo", "caTools", "coda", "crul", "daymetr", "dbplyr", "doParallel", "dplyr", "expm", "forcats", "geonames", "glmmTMB", "haven", "hoardr", "httpuv", "igraph", "imager", "isdparser", "later", "lme4", "mcmc", "MCMCpack", "modelr", "MODISTools", "mvtnorm", "ncdf4", "openair", "PBSmapping", "permute", "polynom", "purrr", "quantreg", "R6", "RandomFields", "RandomFieldsUtils", "raster", "Rcpp", "RcppEigen", "RCurl", "readr", "readxl", "reshape", "rgdal", "rgeos", "rgl", "rjags", "rlang", "rmarkdown", "rnoaa", "rstudioapi", "rvest", "shiny", "slam", "sn", "spam", "spData", "spdep", "stringi", "stringr", "testthat", "tibble", "tidyr", "tidyselect", "tinytex", "urltools", "vegan", "webshot", "xfun", "XML", "xtable", "zip", "zoo"))
library(TMB)
library(devtools)
install.packages('Matrix')
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
library(TMB)
install.packages('TMB', type = 'source')
install.packages("TMB", type = "source")
library(TMB)
library(INLA)
install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
library(devtools)
install.github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
library(FishStatsUtils)
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
version()
Version()
version
library(devtools)
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
install_github("james-thorson/VAST", INSTALL_opts="--no-staged-install")
version
install.packages(c("BH", "bit", "broom", "callr", "caTools", "checkmate", "cli", "data.table", "deldir", "Deriv", "DiagrammeR", "dplyr", "DT", "fansi", "farver", "fields", "fmsb", "foreach", "foreign", "ggridges", "gh", "gstat", "hexbin", "Hmisc", "hms", "jsonlite", "knitr", "latticeExtra", "loo", "mapproj", "mime", "mixtools", "mnormt", "mvtnorm", "prettyunits", "processx", "quantreg", "RandomFields", "raster", "RCurl", "RJSONIO", "rlang", "rmarkdown", "rsconnect", "rstan", "rstudioapi", "segmented", "sf", "shinyjs", "slam", "sn", "spacetime", "spam", "SparseM", "spData", "StanHeaders", "stringi", "threejs", "tidyr", "tidyselect", "tinytex", "TMB", "vctrs", "visNetwork", "xfun", "XML", "xts", "yaml", "zoo"))
library(TMB)
library(devtools)
install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
install_github("james-thorson/FishStatsUtils", INSTALL_opts="--no-staged-install")
library(INLA
)
library(INLA)
library(INLA)
library(devtools)
install.packages('digest')
library(devtools)
install.packages("automap")
library(devtools)
devtools::install_local('C:/Users/Zack Oyafuso/Downloads/SamplingStrata-master/', upgrade = 'never', depen)
devtools::install_local('C:/Users/Zack Oyafuso/Downloads/SamplingStrata-master/', upgrade = 'never', dependencies = F)
?buildFrame
# devtools::install_local('C:/Users/Zack Oyafuso/Downloads/SamplingStrata-master/', upgrade = 'never', dependencies = F)
library(SamplingStrata)
?buildFrame
?buildFrameSpatial
?optimizeStrataSpatial
# devtools::install_local('C:/Users/Zack Oyafuso/Downloads/SamplingStrata-master/', upgrade = 'never', dependencies = F)
library(SamplingStrata)
#############################
# Example of "spatial" method
#############################
library(sp)
# library(devtools)
# devtools::install_local('C:/Users/Zack Oyafuso/Downloads/SamplingStrata-master/', upgrade = 'never', dependencies = F)
library(SamplingStrata)
library(sp)
data("meuse")
data("meuse.grid")
meuse.grid$id <- c(1:nrow(meuse.grid))
coordinates(meuse) <- c('x','y')
coordinates(meuse.grid) <- c('x','y')
library(gstat)
library(automap)
meuse.grid$id <- c(1:nrow(meuse.grid))
coordinates(meuse) <- c('x','y')
coordinates(meuse.grid) <- c('x','y')
v <- variogram(lead ~ dist + soil, data = meuse)
fit.vgm.lead <- autofitVariogram(lead ~ dist + soil,
meuse,
model = "Exp")
plot(v, fit.vgm.lead$var_model)
lead.kr <- krige(lead ~ dist + soil, meuse, meuse.grid,
model = fit.vgm.lead$var_model)
lead.pred <- ifelse(lead.kr[1]$var1.pred < 0,0, lead.kr[1]$var1.pred)
lead.var <- ifelse(lead.kr[2]$var1.var < 0, 0, lead.kr[2]$var1.var)
df <- as.data.frame(list(dom = rep(1,nrow(meuse.grid)),
lead.pred = lead.pred,
lead.var = lead.var,
lon = meuse.grid$x,
lat = meuse.grid$y,
id = c(1:nrow(meuse.grid))))
head(df)
str(df)
frame <-buildFrameSpatial(df = df,
id = "id",
X = c("lead.pred"),
Y = c("lead.pred"),
variance = c("lead.var"),
lon = "lon",
lat = "lat",
domainvalue = "dom")
cv <- as.data.frame(list(DOM = rep("DOM1",1),
CV1 = rep(0.05,1),
domainvalue = c(1:1) ))
str(frame)
meuse.grid$id <- c(1:nrow(meuse.grid))
coordinates(meuse)<-c("x","y")
coordinates(meuse.grid)<-c("x","y")
lm_lead <- lm(log(lead) ~ dist,data=meuse)
# summary(lm_lead)
lm_zinc <- lm(log(zinc) ~ dist,data=meuse)
# summary(lm_zinc)
kriging_lead = autoKrige(log(lead) ~ dist, meuse, meuse.grid)
kriging_lead = autoKrige(log(lead) ~ dist, meuse, meuse.grid)
kriging_zinc = autoKrige(log(zinc) ~ dist, meuse, meuse.grid)
df <- NULL
df$id <- meuse.grid$id
df$lead.pred <- kriging_lead$krige_output@data$var1.pred
df$lead.var <- kriging_lead$krige_output@data$var1.var
df$zinc.pred <- kriging_zinc$krige_output@data$var1.pred
df$zinc.var <- kriging_zinc$krige_output@data$var1.var
df$lon <- meuse.grid$x
df$lat <- meuse.grid$y
df$dom1 <- 1
df <- as.data.frame(df)
head(df)
library(SamplingStrata)
frame <- buildFrameSpatial(df=df,
id="id",
X=c("lead.pred","zinc.pred"),
Y=c("lead.pred","zinc.pred"),
variance=c("lead.var","zinc.var"),
lon="lon",
lat="lat",
domainvalue = "dom1")
cv <- as.data.frame(list(DOM=rep("DOM1",1),
CV1=rep(0.01,1),
CV2=rep(0.01,1),
domainvalue=c(1:1) ))
set.seed(1234)
solution <- optimStrata (
method = "spatial",
errors=cv,
framesamp=frame,
iter = 15,
pops = 10,
nStrata = 5,
fitting = c(summary(lm_lead)$r.square,summary(lm_zinc)$r.square),
range = c(kriging_lead$var_model$range[2],kriging_zinc$var_model$range[2]),
kappa=1,
writeFiles = FALSE,
showPlot = FALSE,
parallel = FALSE)
framenew <- solution$framenew
outstrata <- solution$aggr_strata
head(framenew)
str(framenew)
str(outstrata)
#Plot resuts
frameres <- SpatialPointsDataFrame(data=framenew, coords=cbind(framenew$LON,framenew$LAT) )
frameres2 <- SpatialPixelsDataFrame(points=frameres[c("LON","LAT")], data=framenew)
frameres2$LABEL <- as.factor(frameres2$LABEL)
spplot(frameres2,c("LABEL"), col.regions=bpy.colors(5))
#Select Sample
s <- selectSample(framenew,outstrata,writeFiles=FALSE)
s
optimStrata
library(SamplingStrata)
optimStrata
optimizeStrataSpatial
optimizeStrataSpatial
optimStrata
optimStrata
optimizeStrataSpatial
strataGenalgSpatial
buildStrataDFSpatial
buildStrataDFSpatial
library(SpatialStrata)
library(SamplingStrata)
optimStrata
optimizeStrataSpatial
strataGenalgSpatial
strataGenalgSpatial
library(SamplingStrata)
?rbgaSpatial
library(rnaturalearth)
devtools::install_github("ropensci/rnaturalearth")
traceback()
plot_maps(plot_set=plot_settings$plot_num[i],
Report=Report,
TmbData = TmbData,
Sdreport=Opt$SD,
PlotDF=MapDetails_List[["PlotDF"]],
MapSizeRatio=MapDetails_List[["MapSizeRatio"]],
working_dir = paste0(DateFile, plot_settings$var_name[i], '/' ),
Year_Set=Year_Set, Years2Include=Years2Include,
col = rev(heat.colors(100)),
mar=c(0,0,2,0), oma=c(3.5,3.5,0,0), cex=1.8,
category_names=levels(Data_Geostat[,'spp']))
library(VAST); library(mvtnorm)
install.packages("rnaturalearth")
library(rnaturalearth)
traceback(0)
traceback()
library(rastser)
library(raster)
library(rnaturalearth)
env <- asNamespace("rnaturalearth")
head(getNamespaceInfo(env, "S3methods"))
env <- asNamespace("rnaturalearth'0
env <- asNamespace("rnaturalearth')
env <- asNamespace("rnaturalearth")
update.packages(ask = FALSE, checkBuilt = TRUE)
update.packages(ask = FALSE, checkBuilt = TRUE)
remove.packages("rnaturalearth", lib="~/R/win-library/3.5")
install.packages('rnaturalearth')
library(rnaturalearth)
require(rnaturalearth)
devtools::install_github("ropenscilabs/rnaturalearthdata")
install.packages("rnaturalearthhires",
repos = "http://packages.ropensci.org",
type = "source")
library(rnaturalearthdata)
library(rnaturalearth)
library(rnaturalearth)
library(rnaturalearth)
library(rnaturalearth)
library(rnaturalearth)
source('C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/Model_Settings.R', echo=TRUE)
setwd( 'C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/')
modelno = '1c'
if(!dir.exists(paste0(getwd(), '/VAST_output', modelno, '/'))) {
dir.create(paste0(getwd(), '/VAST_output', modelno, '/'))
}
Version = get_latest_version( package="VAST" )
## Model settings
FieldConfig = c("Omega1"=3, "Epsilon1"=3, "Omega2"=3, "Epsilon2"=3)
RhoConfig = c("Beta1"=0, "Beta2"=0, "Epsilon1"=0, "Epsilon2"=0)
OverdispersionConfig = c("Eta1"=0, "Eta2"=0)
ObsModel = c(2,0)
##Derived Products: We also decide on which post-hoc calculations to include in the output
Options =  c("SD_site_density"=0,
"SD_site_logdensity"=0,
"Project_factors" = 0)
save.image(paste0(getwd(), '/VAST_output', modelno, '/Model_Settings.RData') )
###############################
## Spatial Settings for VAST
###############################
rm(list = ls())
library(VAST)
setwd( 'C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/')
modelno = '1c'
if(!dir.exists(paste0(getwd(), '/VAST_output', modelno, '/'))) {
dir.create(paste0(getwd(), '/VAST_output', modelno, '/'))
}
## Import Data
data = read.csv(file = 'data/data/GOA_multspp.csv')
# Prepare the Data-frame for catch-rate data
Data_Geostat = data.frame( "spp"=data$SPECIES_NAME,
"Year"=data$YEAR,
"Catch_KG"=data$WEIGHT,
"AreaSwept_km2"=data$EFFORT,
"Vessel"=0,
"Lat"=data$LATITUDE,
"Lon"=data$LONGITUDE,
"DEPTH" = data$DEPTH,
"DEPTH2" = data$DEPTH2)
rm(data)
#Drop factor levels of unused Species
spp_df = read.csv("spp_df.csv", check.names=F, header = T, row.names = 'modelno')
which_spp = unlist(spp_df[modelno,])
which_spp
Data_Geostat = subset(Data_Geostat, spp %in% names(which_spp)[which_spp])
Data_Geostat$spp = droplevels(Data_Geostat$spp)
levels(Data_Geostat$spp)
## Spatial settings: The following settings define the spatial resolution
## for the model, and whether to use a grid or mesh approximation
Method = c("Grid", "Mesh", "Spherical_mesh")[2]
#grid_size_km = 50
n_x = 250   # Specify number of stations (a.k.a. "knots")
## Stratification for results
strata.limits <- data.frame(
'STRATA' = c("All_areas"),#, "west_of_140W"),
'west_border' = c(-Inf),#, -Inf),
'east_border' = c(Inf)#, -140)
)
Extrapolation_List = make_extrapolation_info( Region= "Gulf_of_Alaska",
strata.limits = strata.limits )
fine_scale = T
Spatial_List = make_spatial_info( n_x=n_x,
Method=Method,
Lon_i=Data_Geostat[,'Lon'],
Lat_i=Data_Geostat[,'Lat'],
Extrapolation_List=Extrapolation_List,
DirPath=paste0(getwd(), '/VAST_output',
modelno, '/'),
fine_scale = fine_scale,
Save_Results=T )
# Add knots to Data_Geostat
Data_Geostat = cbind( Data_Geostat,
"knot_i"=Spatial_List$knot_i )
#plot data points and knots
plot(Spatial_List$latlon_i[,2:1])
points(Spatial_List$latlon_x[,2:1], col = 'red', pch = 16, cex = 1)
#plot data points and knots
plot(Spatial_List$latlon_i[,2:1])
points(Spatial_List$latlon_x[,2:1], col = 'red', pch = 16, cex = 1)
save.image(paste0(getwd(), '/VAST_output', modelno, '/Spatial_Settings.RData') )
rm(list = ls())
# Getting started
#utils::install.packages( "https://inla.r-inla-download.org/R/stable/bin/windows/contrib/3.5/INLA_18.07.12.zip" )
#library(INLA)
library(TMBdebug)
#library(devtools)
#devtools::install_local("C:/Users/Zack Oyafuso/Downloads/FishStatsUtils-2.5.0")
library(VAST)
modelno = "1c"
setwd(paste0('C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/VAST_output', modelno))
## Import Settings
load('Model_Settings.RData')
load('Spatial_Settings.RData')
TmbData = make_data("Version"=Version,
"FieldConfig"=FieldConfig,
"OverdispersionConfig"=OverdispersionConfig,
"RhoConfig"=RhoConfig,
"ObsModel_ez" = c(PosDist = 2, Link = 0),
"c_i"=as.numeric(Data_Geostat[,'spp'])-1,
"b_i"=Data_Geostat[,'Catch_KG'],
"a_i"=Data_Geostat[,'AreaSwept_km2'],
"v_i"=as.numeric(Data_Geostat[,'Vessel'])-1,
"s_i"=Data_Geostat[,'knot_i']-1,
"t_i"=Data_Geostat[,'Year'],
"spatial_list"=Spatial_List,
"Options"=Options ,
formula = "Catch_KG ~ DEPTH + DEPTH2",
covariate_data = cbind(Data_Geostat[,c('Lat', 'Lon',
'DEPTH', 'DEPTH2',
'Catch_KG')],
Year = NA)
)
#Add "true" and not interpolated covariate data
load('../Extrapolation_depths.RData')
X_gtp = array(dim = c(TmbData$n_g,TmbData$n_t, TmbData$n_p) )
for(i in 1:TmbData$n_t) {
X_gtp[,i,] = as.matrix(Extrapolation_depths[,c('DEPTH', 'DEPTH2')])
}
TmbData$X_gtp = X_gtp
unique(Data_Geostat$spp)
unique(Data_Geostat$Year)
sort(unique(Data_Geostat$Year))
TmbList = make_model("TmbData"=TmbData,
"RunDir"= getwd(),
"Version"=Version,
"RhoConfig"=RhoConfig,
"loc_x"=Spatial_List$loc_x,
"Method"=Spatial_List$Method)
Obj = TmbList[["Obj"]]
## Estimate fixed effects and predict random effects: Next, we use a gradient-based nonlinear minimizer to identify maximum likelihood estimates for fixed-effects
?TMBhelper::fit_tmb
## Estimate fixed effects and predict random effects: Next, we use a gradient-based nonlinear minimizer to identify maximum likelihood estimates for fixed-effects
bias_correct = T
Opt = TMBhelper::fit_tmb( obj=Obj,
lower=TmbList[["Lower"]],
upper=TmbList[["Upper"]],
getsd=TRUE,
getJointPrecision = TRUE,
savedir=getwd(),
bias.correct=bias_correct,
quiet = T,
newtonsteps=1 )
#Finally, we bundle and save output
Report = Obj$report()
Save = list('Obj' = Obj,"Opt"=Opt, "Report"=Report, "TmbData"=TmbData,
'Spp' = levels(Data_Geostat$spp), "ParHat"=Obj$env$parList(Opt$par),
'TmbList' = TmbList)
save(Save, file="VAST_MS_GoA_Run.RData")
