Save = list("Opt"=Opt,
"Report"=Report,
"ParHat"=Obj$env$parList(Opt$par),
"TmbData"=TmbData)
save(Save, file=paste0(DateFile,"Save.RData"))
####################################
## Diagnostic Plots:
## Data
####################################
plot_data(Extrapolation_List=Extrapolation_List,
Spatial_List=Spatial_List,
Data_Geostat=Data_Geostat,
PlotDir=DateFile )
####################################
## Diagnostic Plots:
## Convergence
####################################
Opt$diagnostics[,c('Param','Lower','MLE','Upper','final_gradient')]
readRDS('C:/Users/Zack Oyafuso/Downloads/GOA_predict_data.rds')
readRDS('C:/Users/Zack Oyafuso/Downloads/GOA_predict_data.rds')
test = readRDS('C:/Users/Zack Oyafuso/Downloads/GOA_predict_data.rds')
str(test)
head(test)
test = readRDS('C:/Users/Zack Oyafuso/Google Drive/SDMTBM/GOA_predict_data.rds')
test2 = readRDS('C:/Users/Zack Oyafuso/Google Drive/SDMTBM/Predict_data_AK.Rds')
head(test)
head(test2)
str(test2)
str(test2)
library(ggplot2)
library(dplyr)
library(sdmTMB)
library(devtools)
devtools::install_github("pbs-assess/sdmTMB")
library(ggplot2)
library(dplyr)
library(sdmTMB)
glimpse(pcod)
head(pcod)
pcod_spde <- make_spde(pcod$X, pcod$Y, n_knots = 100)
plot_spde(pcod_spde)
m <- sdmTMB(
data = pcod,
formula = density ~ 0 + as.factor(year),
time = "year", spde = pcod_spde, family = tweedie(link = "log")
)
str(m)
m
?sdmTMB
pcod$resids <- residuals(m) # randomized quantile residuals
hist(pcod$resids)
qqnorm(pcod$resids)
abline(a = 0, b = 1)
ggplot(pcod, aes(X, Y, col = resids)) + scale_colour_gradient2() +
geom_point() + facet_wrap(~year) + coord_fixed()
glimpse(qcs_grid)
predictions <- predict(m, newdata = qcs_grid, return_tmb_object = TRUE)
plot_map <- function(dat, column) {
ggplot(dat, aes_string("X", "Y", fill = column)) +
geom_raster() +
facet_wrap(~year) +
coord_fixed()
}
plot_map(predictions$data, "exp(est)") +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)")
plot_map(predictions$data, "exp(est_non_rf)") +
ggtitle("Prediction (fixed effects only)") +
scale_fill_viridis_c(trans = "sqrt")
plot_map(predictions$data, "omega_s") +
ggtitle("Spatial random effects only") +
scale_fill_gradient2()
plot_map(predictions$data, "epsilon_st") +
ggtitle("Spatiotemporal random effects only") +
scale_fill_gradient2()
# not bias correcting for vignette-building speed:
ind <- get_index(predictions, bias_correct = FALSE)
# scale the biomass by the area and adjust units;
scale <- 2 * 2 / 1000 # 2 x 2 km grid and converted from kg to tonnes
ggplot(ind, aes(year, est*scale)) + geom_line() +
geom_ribbon(aes(ymin = lwr*scale, ymax = upr*scale), alpha = 0.4) +
xlab('Year') + ylab('Biomass estimate (metric tonnes)')
mutate(ind,
est = est * scale,
lwr = lwr * scale,
upr = upr * scale,
cv = sqrt(exp(se^2) - 1)
) %>%
select(-log_est, -max_gradient, -bad_eig, -se) %>%
knitr::kable(format = "pandoc", digits = c(0, 0, 0, 0, 2))
lwr
?sdmTMB::predict.sdmTMB
head(qcs_grid)
table(qcs_grid$year)
table(qcs_grid$X)
dim(qcs_grid)
length(unique(qcs_grid$year))
65825/9
head(subset(qcs_grid, year == 2003))
head(subset(qcs_grid, year == 2003))
head(subset(qcs_grid, year == 2005))
head(subset(qcs_grid, year == 2007))
tail(subset(qcs_grid, year == 2003))
tail(subset(qcs_grid, year == 2005))
tail(subset(qcs_grid, year == 2007))
2004:2012
(2004:2012)%in%unique(qcs_grid$year)
(2004:2012)[!(2004:2012)%in%unique(qcs_grid$year)]
unique(qcs_grid$year)
iyear = 2006
head(subset(qcs_grid, year == 2007, select = -year))
head(  cbind(subset(qcs_grid, year == 2007, select = -year), year = iyear))
#Add unobserved years
for(iyear in (2004:2012)[!(2004:2012)%in%unique(qcs_grid$year)] ){
qcs_grid = rbind(qcs_grid, cbind(subset(qcs_grid,
year == 2007,
select = -year),
year = iyear) )
}
qcs_grid = qcs_grid[order(qcs_grid$year),]
tail(qcs_grid)
#Add unobserved years
for(iyear in (2004:2017)[!(2004:2017)%in%unique(qcs_grid$year)] ){
qcs_grid = rbind(qcs_grid, cbind(subset(qcs_grid,
year == 2007,
select = -year),
year = iyear) )
}
qcs_grid = qcs_grid[order(qcs_grid$year),]
tail(qcs_grid)
unique(qcs_grid)
unique(qcs_grid$year)
#Now make the predictions on new data:
predictions <- predict(
m,
newdata = qcs_grid,
return_tmb_object = TRUE)
library(ggplot2)
library(dplyr)
library(sdmTMB)
#Let's perform index standardization with the built-in data for Pacific cod.
# - I've included columns for depth and depth squared.
# - Depth was centred and scaled by its standard deviation and I've included those in the data frame so that they could be used to similarly scale the prediction grid.
# - The density units should be kg/km^2^.
# - Here, X and Y are coordinates in UTM zone 9.
glimpse(pcod)
#First we will create our SPDE mesh. We will use 100 knots for a balance between speed and accuracy in this vignette. You will likely want to use more for applied scenarios. You will want to make sure that increasing the number of knots does not change the conclusions.
pcod_spde <- make_spde(pcod$X, pcod$Y, n_knots = 100)
plot_spde(pcod_spde)
#Let's fit a GLMM. Note that if we want to use this model for index standardization then we need to include `0 + as.factor(year)` or `-1 + as.factor(year)` so that we have a factor predictor that represents the mean estimate for each time slice.
head9pcod
head(pcod)
m <- sdmTMB(
data = pcod,
formula = density ~ 0 + as.factor(year) + depth,
time = "year",
spde = pcod_spde,
family = tweedie(link = "log")
)
m
head(pcod)
head(as.data.frame(pcod))
m <- sdmTMB(
data = pcod,
formula = density ~ 0 + as.factor(year) + depth_scaled,
time = "year",
spde = pcod_spde,
family = tweedie(link = "log")
)
m
m <- sdmTMB(
data = pcod,
formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
time = "year",
spde = pcod_spde,
family = tweedie(link = "log")
)
pcod$resids <- residuals(m) # randomized quantile residuals
hist(pcod$resids)
qqnorm(pcod$resids)
abline(a = 0, b = 1)
ggplot(pcod, aes(X, Y, col = resids)) + scale_colour_gradient2() +
geom_point() + facet_wrap(~year) + coord_fixed()
glimpse(qcs_grid)
predictions <- predict(
m,
newdata = qcs_grid,
return_tmb_object = TRUE)
#Let's make a small function to make maps.
plot_map <- function(dat, column) {
ggplot(dat, aes_string("X", "Y", fill = column)) +
geom_raster() +
facet_wrap(~year) +
coord_fixed()
}
#There are four kinds of predictions that we get out of the model. First we will show the predictions that incorporate all fixed effects and random effects:
plot_map(predictions$data, "exp(est)") +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)")
plot_map(predictions$data, "exp(est_non_rf)") +
ggtitle("Prediction (fixed effects only)") +
scale_fill_viridis_c(trans = "sqrt")
# not bias correcting for vignette-building speed:
ind <- get_index(predictions, bias_correct = FALSE)
# scale the biomass by the area and adjust units;
scale <- 2 * 2 / 1000 # 2 x 2 km grid and converted from kg to tonnes
ggplot(ind, aes(year, est*scale)) + geom_line() +
geom_ribbon(aes(ymin = lwr*scale, ymax = upr*scale), alpha = 0.4) +
xlab('Year') + ylab('Biomass estimate (metric tonnes)')
#These are our biomass estimates:
mutate(ind,
est = est * scale,
lwr = lwr * scale,
upr = upr * scale,
cv = sqrt(exp(se^2) - 1)
) %>%
select(-log_est, -max_gradient, -bad_eig, -se) %>%
knitr::kable(format = "pandoc", digits = c(0, 0, 0, 0, 2))
m
var(residuals(m))
sqrt(var(residuals(m)))
summary(m)
m$tmb_params
str(m$tmb_params)
m$sd_report
library(openrose)
install.packages('openair')
library(openair)
# basic plot
windRose(mydata)
head(windRose)
head(mydata)
# one windRose for each year
windRose(mydata,type = "year")
load('C:/Users/Zack Oyafuso/Google Drive/EwE/HI_EwE/results.RData')
str(ind_ar)
dimnames(ind_ar)
ind_ar
args(windRose
)
args(pollutionRose)
install.packages("plotrix")
library(plotrix)
?radial.pie
pie1<-c(3,6,5,4,7,8,9,1,4)
pie2<-list(0:3,1:6,2:5,1:4,0:7,4:8,2:9,0:1,0:4)
pie3<-sample(10:60,36)
pie4<-list(sort(sample(1:60,8)))
pie1
pie2
pie3
pie4
for(sector in 2:36) pie4[[sector]]<-sort(sample(1:60,8))
oldpar<-radial.pie(pie1,labels=LETTERS[1:9])
pie1
load('C:/Users/Zack Oyafuso/Google Drive/EwE/HI_EwE/results.RData')
library(plotrix)
radial.pie(c(1,2,3), labels=c("One", "Two", "Three"), radlab=TRUE)
ind_ar[1,]
abs(ind_ar[1,])*100
radial.pie(abs(ind_ar[1,])*100)
abs(ind_ar[1,])*100
radial.pie(as.vector(abs(ind_ar[1,])*100))
radial.pie(c(1,2,3), labels=c("One", "Two", "Three"), radlab=TRUE)
as.vector(abs(ind_ar[1,])*100)
dimnames(ind_ar)[[2]]
radial.pie(as.vector(abs(ind_ar[1,])*100), labels = dimnames(ind_ar)[[2]] )
radial.pie(as.vector(abs(ind_ar[1,-11])*100), labels = dimnames(ind_ar)[[2]] )
ind_ar[1,-11]
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red') )
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'), radial.lim = c(0,100)
)
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
par(mar = c(5,5,5,5))
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
par(oma= c(5,5,5,5))
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
radial.pie(as.vector(abs(ind_ar[1,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[1,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), xpd = NA
)
i = 1
i = 2
par(oma= c(5,5,5,5))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
i = 2
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100)
)
nrow(ind_ar)
for(i in 1:nrow(ind_ar)){
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
for(i in 1:nrow(ind_ar)){
par(oma= c(1,1,1,1))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
par(oma= c(2,2,2,2))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
par(oma= c(5,5,5,5))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100),
)
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(5,5,5,5)
)
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(1,1,1,1))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(0,0,0,0))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(10,10,10,10))
}
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = c(20,20,20,20))
}
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(15,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(12,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(11,4))
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(10,4))
for(i in 1:nrow(ind_ar)){
radial.pie(as.vector(abs(ind_ar[i,-11])*100),
labels = dimnames(ind_ar)[[2]][-11],
sector.colors = ifelse(ind_ar[i,-11] > 0, 'blue', 'red'),
radial.lim = c(0,100), mar = rep(10,4))
}
ind_ar
model_no = 1
setwd('C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/')
dir('VAST_output1/')
load(paste0('VAST_output', model_no, '/VAST_MS_GoA_Run.RData'))
sds = sdreport(Save$Opt, par.fixed = NULL, hessian.fixed = NULL,
getJointPrecision = FALSE, bias.correct = T,
bias.correct.control = list(sd = T, split = NULL, nsplit = NULL),
ignore.parm.uncertainty = FALSE, getReportCovariance = TRUE,
skip.delta.method = FALSE)
# Getting started
library(TMB)               # Can instead load library(TMBdebug)
library(VAST)
sds = sdreport(Save$Opt, par.fixed = NULL, hessian.fixed = NULL,
getJointPrecision = FALSE, bias.correct = T,
bias.correct.control = list(sd = T, split = NULL, nsplit = NULL),
ignore.parm.uncertainty = FALSE, getReportCovariance = TRUE,
skip.delta.method = FALSE)
sds = sdreport(Save$Obj, par.fixed = NULL, hessian.fixed = NULL,
getJointPrecision = FALSE, bias.correct = T,
bias.correct.control = list(sd = T, split = NULL, nsplit = NULL),
ignore.parm.uncertainty = FALSE, getReportCovariance = TRUE,
skip.delta.method = FALSE)
Save$Obj
TmbList
names(Save$Obj)
########################
## Build and Run Multispecies VAST
########################
rm(list = ls())
# Getting started
library(TMB)               # Can instead load library(TMBdebug)
library(VAST)
setwd('C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/')
## Import Settings
load('data/Model_Settings.RData')
load('data/Spatial_Settings.RData')
## Save settings: We then set the location for saving files.
model_no = 1
DateFile = paste0('VAST_output', model_no)
if(!dir.exists(DateFile)) dir.create(DateFile)
## remove unused species factors if only using a subset of the species in the df
#Subset species
Data_Geostat$spp = droplevels(Data_Geostat)$spp
# Build and run model
## Build model: To estimate parameters, we first build a list of data-inputs used for parameter estimation.  `make_data` has some simple checks for buggy inputs, but also please read the help file `?make_data`.
#We then build the TMB object.
TmbData = make_data("Version"=Version,
"FieldConfig"=FieldConfig,
"OverdispersionConfig"=OverdispersionConfig,
"RhoConfig"=RhoConfig,
"ObsModel_ez" = c(PosDist = 2, Link = 0),
"c_i"=as.numeric(Data_Geostat[,'spp'])-1,
"b_i"=Data_Geostat[,'Catch_KG'],
"a_i"=Data_Geostat[,'AreaSwept_km2'],
"v_i"=as.numeric(Data_Geostat[,'Vessel'])-1,
"s_i"=Data_Geostat[,'knot_i']-1,
"t_i"=Data_Geostat[,'Year'],
"spatial_list"=Spatial_List,
"Options"=Options ,
formula = "Catch_KG ~ DEPTH + DEPTH2",
covariate_data = cbind(Data_Geostat[,c('Lat', 'Lon',
'DEPTH', 'DEPTH2',
'Catch_KG')],
Year = NA)
)
TmbList = make_model("TmbData"=TmbData,
"RunDir"= getwd(),
"Version"=Version,
"RhoConfig"=RhoConfig,
"loc_x"=Spatial_List$loc_x,
"Method"=Spatial_List$Method)
Obj = TmbList[["Obj"]]
load('VAST_output1/VAST_MS_GoA_Run')
names(Obj)
TmbList
Save
load('VAST_output1/VAST_MS_GoA_Run.RData')
names(Save)
Save$TmbList = TmbList
DateFile
names(Save)
save(Save, file=paste0(DateFile,"VAST_MS_GoA_Run.RData"))
rm(list = ls())
# Getting started
library(TMB)               # Can instead load library(TMBdebug)
library(VAST)
setwd('C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/')
model_no = 1
load(paste0('VAST_output', model_no, '/VAST_MS_GoA_Run.RData'))
names(Save)
load(paste0('VAST_output', model_no, '/VAST_MS_GoA_Run.RData'))
names(Save)
Save$TmbList[["Lower"]]
Opt = TMBhelper::fit_tmb( obj=Save$Obj,
lower=Save$TmbList[["Lower"]],
upper=Save$TmbList[["Upper"]],
startpar = Save$Opt$par,
getsd=T,
savedir=DateFile,
bias.correct=T,
bias.correct.control=list(
sd=T, split=NULL,
nsplit=1, vars_to_correct="Index_cyl"),
newtonsteps=1 )
